# Behavioural Patterns Homework

----
## Mediator Pattern

> This pattern is used so that different classes can interact with each other without the explicit need of knowledge of the existance of each one of them. The control of interaction is not direct - class to another class, but is rather class - mediator - targeted class. In this case the first class doesn't have to 'know' almost anything about the targeted class. Great real-world examples of this pattern are the air control tower in airports, dispatcher that taxis use and so on.

> Implementing this pattern makes our code more loosely coupled and makes interaction between classes more easy.

> One disadvantage is that the code in that mediator class could become really large and complex.

----
### Diagram
![Mediator Pattern](http://www.dofactory.com/images/diagrams/net/mediator.gif "Mediator Design Pattern")

----

----
## Iterator Pattern

> The Iterator Design Pattern is used to implement traversion of data structures that are more complex and their traversal is more complex (trees, graphs and so on) and could vary depending on the need. The class that needs to be traversed usually implements interface IEnumerable, that declares method GetEnumerator. The implementation class of the enumeration must implement the IEnumerator interface, that usually consists of the methods MoveNext(), Current(), Reset().

> The interface is usually commonly used and is lightweigh with no major drawbacks to it.

----
### Diagram
![iterator Pattern](https://upload.wikimedia.org/wikipedia/commons/1/13/Iterator_UML_class_diagram.svg "Iterator Design Pattern")

----
## Template Pattern

> Template method is usually used when there is certain algorithm that is implemented throughout various modules, classes or so on. It defines the steps that are needed to be covered, but doesn't specifically point the exact way that those steps are implemented. Usually relies on inheritacnce and override of virtual methods.

> Another major advantage of the template method is that if some steps are required to be implemented in exact way, this could be done in the template method itself thus avoiding duplication of code (DRY principle is preserved)

----
### Diagram
![Singleton Pattern](http://docs.groovy-lang.org/latest/html/documentation/assets/img/TemplateMethodClasses.gif "Template Design Pattern")

----
## Strategy Pattern

> The strategy design pattern is actually an implementation of the Dependency Inversion Principle - one of the five SOLID principles when writing code: The main purpose is to decouple classes with one another using higher abstraction introduced through interfaces. In this way different parts of the program can be replaced/changed when needed without the need to change the established structure. This way new functionality could be added relative easy. Different parts can be unit testsed. Classes are more loosly coupled and remain single purposed. 

----
### Diagram
![Strategy Pattern](http://www.dofactory.com/images/diagrams/net/strategy.gif "Strategy Design Pattern")
